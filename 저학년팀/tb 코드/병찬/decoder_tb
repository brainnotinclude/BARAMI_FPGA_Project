`timescale 1ns / 1ps
module decoder_tb;

    // Inputs
    reg clk;
    reg rst_n;
    reg [31:0] instA;
    reg [31:0] instB;
    reg [31:0] pcA;
    reg [31:0] pcB;
    reg [31:0] forwarding;
    reg [4:0] forwarding_addr;
    reg [31:0] s1A;
    reg [31:0] s2A;
    reg [31:0] s1B;
    reg [31:0] s2B;
    reg rs1A_valid;
    reg rs2A_valid;
    reg rs1B_valid;
    reg rs2B_valid;

    // Outputs
    wire [82:0] decoded_instA;
    wire [82:0] decoded_instB;
    wire map_en_A;
    wire map_en_B;
    wire [4:0] rs1A;
    wire [4:0] rs2A;
    wire [4:0] rs1B;
    wire [4:0] rs2B;
    wire [4:0] rdA;
    wire [4:0] rdB;
    wire error_A;
    wire error_B;

    // Instantiate the Unit Under Test (UUT)
    decoder uut (
        .clk(clk),
        .rst_n(rst_n),
        .instA(instA),
        .instB(instB),
        .pcA(pcA),
        .pcB(pcB),
        .forwarding(forwarding),
        .forwarding_addr(forwarding_addr),
        .s1A(s1A),
        .s2A(s2A),
        .s1B(s1B),
        .s2B(s2B),
        .rs1A_valid(rs1A_valid),
        .rs2A_valid(rs2A_valid),
        .rs1B_valid(rs1B_valid),
        .rs2B_valid(rs2B_valid),
        .decoded_instA(decoded_instA),
        .decoded_instB(decoded_instB),
        .map_en_A(map_en_A),
        .map_en_B(map_en_B),
        .rs1A(rs1A),
        .rs2A(rs2A),
        .rs1B(rs1B),
        .rs2B(rs2B),
        .rdA(rdA),
        .rdB(rdB),
        .error_A(error_A),
        .error_B(error_B)
    );

    // Clock generation
    initial begin
        clk = 0;
        forever #5 clk = ~clk;  // 10ns clock period
    end

    // Stimulus process
    initial begin
        // Initialize Inputs
        rst_n = 0;
        instA = 32'h00000000;
        instB = 32'h00000000;
        pcA = 32'h00000000;
        pcB = 32'h00000000;
        forwarding = 32'h00000000;
        forwarding_addr = 5'd0;
        s1A = 32'h00000000;
        s2A = 32'h00000000;
        s1B = 32'h00000000;
        s2B = 32'h00000000;
        rs1A_valid = 0;
        rs2A_valid = 0;
        rs1B_valid = 0;
        rs2B_valid = 0;

        // Apply reset
        #10;
        rst_n = 1;
        
        // Apply first set of instructions
        instA = 32'hAABBCCDD; // Test instruction A
        instB = 32'h11223344; // Test instruction B
        pcA = 32'h00000010;   // Program counter for A
        pcB = 32'h00000014;   // Program counter for B
        s1A = 32'h12345678;   // Source 1 data for A
        s2A = 32'h9ABCDEF0;   // Source 2 data for A
        s1B = 32'h11111111;   // Source 1 data for B
        s2B = 32'h22222222;   // Source 2 data for B
        rs1A_valid = 1;       // Valid signal for source 1 of A
        rs2A_valid = 1;       // Valid signal for source 2 of A
        rs1B_valid = 1;       // Valid signal for source 1 of B
        rs2B_valid = 1;       // Valid signal for source 2 of B
        forwarding = 32'h55555555;   // Forwarding data
        forwarding_addr = 5'd1;      // Forwarding address

        #20; // Wait for 20ns to observe the outputs

        // Apply second set of instructions
        instA = 32'hDEADBEEF; // Another test instruction A
        instB = 32'hCAFEBABE; // Another test instruction B
        pcA = 32'h00000020;   // Updated program counter for A
        pcB = 32'h00000024;   // Updated program counter for B
        s1A = 32'h33333333;   // New source 1 data for A
        s2A = 32'h44444444;   // New source 2 data for A
        s1B = 32'h55555555;   // New source 1 data for B
        s2B = 32'h66666666;   // New source 2 data for B
        rs1A_valid = 1;       // Keep valid signals the same
        rs2A_valid = 1;
        rs1B_valid = 1;
        rs2B_valid = 1;
        forwarding = 32'h77777777;   // New forwarding data
        forwarding_addr = 5'd2;      // New forwarding address

        #20; // Wait for 20ns to observe the outputs

        // Add more test cases as needed
        // ...
        
        // Finish simulation
        #100;
        $finish;
    end

endmodule
