목적: 선배님들이 정리해주신 ISA 목록에 따라 명령어가 대응되면 그것을 기계어로 변환하는 어셈블러 (어셈블러어에 대한 일종의 컴파일러인 셈.)를 구현한다.

현재 진행 상황:
모드 1 작업 중. UI와 연결 후 sub까지 기능함.





모드 1: cmd 창에서 입력하면 즉각 기계어를 작성해내어 화면에 출력

문법:
<변수명> = <숫자> (단, 하단 명령어들은 기왕이면 변수명으로 사용하지 말아주십쇼..)
입력시 변수 지정 가능.
! 입력시 현재 레지스터 상태와 변수 현황 확인 가능.
R0 : 0번 레지스터의 주솟값.
RV0 : 0번 레지스터에 저장된 값.
>> 레지스터 현황 파악 기능을 위해 별 수 없이 추가됨.
ex. r0와 r1에 저장된 값을 add를 통해 r2에 저장하고 싶은 경우.
add R2 RV0 RV1 

출력 형태:
<instruction>: <결과 레지스터> = <저장된 값>
Result: <기계어> 

명령어: // 현재 unsigned int 가 사용된 것들은 c++ bitset을 통과함에 따라 어떻게 변화하는지 확인 필요.
mov <입력 데이터> <입력 대상> - 레지스터에 임의로 값 집어 넣을 때 이용.
add <rd> <rs1> <rs2>
sub <rd> <rs1> <rs2>
and <rd> <rs1> <rs2>
or <rd> <rs1> <rs2>
xor <rd> <rs1> <rs2>
sll <rd> <rs1> <rs2>
srl <rd> <rs1> <rs2>
sra <rd> <rs1> <rs2>
slt <rd> <rs1> <rs2>
sltu <rd> <rs1> <rs2>
addi <rd> <rs1> <imm>
andi <rd> <rs1> <imm>
ori <rd> <rs1> <imm>
xori <rd> <rs1> <imm>
slli <rd> <rs1> <imm>
srli <rd> <rs1> <imm>
srai <rd> <rs1> <imm>
slti <rd> <rs1> <imm>
sltiu <rd> <rs1> <imm>
lw <rd> <rs1> <offset> // 명령어 자체가 메모리에서 값 가져오는 거라 시뮬레이터 내에 반영 안됨. 명령어만 나옴.
jalr <rd> <rs1> <offset>


모드 2: 텍스트 파일 전체를 자동 변환하여 텍스트 파일로 출력. - 문법이 모드 1 과 동일할 것으로 예상됨.
입력: ISA 명령어가 작성된 txt파일.
문법은 모드 1과 동일하며, 명령어 한줄 치고 다음 줄에 새 명령어 작성할 것.
출력:
명령어에 따른 변환된 기계어가 한줄 단위로 출력. 다음 명령어는 아랫줄에.
mov의 경우 레지스터에 값을 집어넣기 위한 명령어이므로, 기계어로 구현되지 않음.



하단부는 미구현.
확인된 내용을 기계어로 변환.
띄워쓰기 구분하여 함수와 매개변수 인식, 문법 검사.
오류 발견시 오류메세지와 더불어 오류난 부분 표시. - 기계어 변환은 중단.
출력:
오류 발생 시 오류 메세지 전파 및 오류난 부분을 txt 파일로 알려주기.
정상적인 경우 기계어(01010110)가 담긴 txt 파일 만들기.
